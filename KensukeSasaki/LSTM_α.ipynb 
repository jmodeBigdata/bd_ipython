{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 13,
   "metadata": {
    "collapsed": true
   },
   "outputs": [],
   "source": [
    "#!/usr/bin/env python\n",
    "# coding: utf-8\n",
    "import numpy as np\n",
    "\n",
    "from __future__ import print_function\n",
    "import argparse\n",
    "import math\n",
    "import time\n",
    "import six\n",
    "import sys\n",
    "import chainer\n",
    "\n",
    "import chainer.links as L\n",
    "import chainer.functions as F\n",
    "from chainer import optimizers\n",
    "from chainer import serializers\n",
    "from chainer import cuda\n",
    "\n",
    "from matplotlib import pyplot\n",
    "import pandas as pd\n",
    "%matplotlib inline"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 14,
   "metadata": {
    "collapsed": false
   },
   "outputs": [],
   "source": [
    "# Prepare dataset\n",
    "temptarget = pd.read_csv(\"LSTM.csv\",header=0)\n",
    "target_list=[]\n",
    "for i in zip(temptarget['value']):\n",
    "    target_list.append([i])\n",
    "target = np.array(target_list)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 15,
   "metadata": {
    "collapsed": true
   },
   "outputs": [],
   "source": [
    "class LSTM(chainer.Chain):\n",
    "    def __init__(self, in_size, n_units, train=True):\n",
    "        super(LSTM, self).__init__(\n",
    "            embed=L.EmbedID(in_size, n_units), #埋め込み層作成\n",
    "            l1=L.LSTM(n_units, n_units),\n",
    "            l2=L.Linear(n_units, 4*in_size),\n",
    "            l3=L.Linear(4*in_size, in_size),   #ベクトルの出口と入口は揃ってないとダメっぽい\n",
    "        )\n",
    "\n",
    "    def __call__(self, x):\n",
    "        h0 = self.embed(x)\n",
    "        h1 = self.l1(h0)\n",
    "        h2 = self.l2(h1)\n",
    "        y = self.l3(h2)\n",
    "        return y\n",
    "\n",
    "    def reset_state(self):\n",
    "        self.l1.reset_state()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 16,
   "metadata": {
    "collapsed": false
   },
   "outputs": [],
   "source": [
    "# 引数の処理\n",
    "parser = argparse.ArgumentParser()\n",
    "#parser.add_argument('--gpu', '-g', default=-1, type=int,help='GPU ID (negative value indicates CPU)')\n",
    "#args = parser.parse_args()\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 17,
   "metadata": {
    "collapsed": true
   },
   "outputs": [],
   "source": [
    "# パラメータ設定\n",
    "p = 100       # 文字列長\n",
    "n_units = 64    # 隠れ層のユニット数"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 18,
   "metadata": {
    "collapsed": false
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[[100   0   1   2   3   4   5   6   7   8   9  10  11  12  13  14  15  16\n",
      "   17  18  19  20  21  22  23  24  25  26  27  28  29  30  31  32  33  34\n",
      "   35  36  37  38  39  40  41  42  43  44  45  46  47  48  49  50  51  52\n",
      "   53  54  55  56  57  58  59  60  61  62  63  64  65  66  67  68  69  70\n",
      "   71  72  73  74  75  76  77  78  79  80  81  82  83  84  85  86  87  88\n",
      "   89  90  91  92  93  94  95  96  97 100]\n",
      " [ 99   0   1   2   3   4   5   6   7   8   9  10  11  12  13  14  15  16\n",
      "   17  18  19  20  21  22  23  24  25  26  27  28  29  30  31  32  33  34\n",
      "   35  36  37  38  39  40  41  42  43  44  45  46  47  48  49  50  51  52\n",
      "   53  54  55  56  57  58  59  60  61  62  63  64  65  66  67  68  69  70\n",
      "   71  72  73  74  75  76  77  78  79  80  81  82  83  84  85  86  87  88\n",
      "   89  90  91  92  93  94  95  96  97  99]]\n",
      "文字列長 100\n"
     ]
    },
    {
     "data": {
      "text/plain": [
       "array([[100,   0,   1,   2,   3,   4,   5,   6,   7,   8,   9,  10,  11,\n",
       "         12,  13,  14,  15,  16,  17,  18,  19,  20,  21,  22,  23,  24,\n",
       "         25,  26,  27,  28,  29,  30,  31,  32,  33,  34,  35,  36,  37,\n",
       "         38,  39,  40,  41,  42,  43,  44,  45,  46,  47,  48,  49,  50,\n",
       "         51,  52,  53,  54,  55,  56,  57,  58,  59,  60,  61,  62,  63,\n",
       "         64,  65,  66,  67,  68,  69,  70,  71,  72,  73,  74,  75,  76,\n",
       "         77,  78,  79,  80,  81,  82,  83,  84,  85,  86,  87,  88,  89,\n",
       "         90,  91,  92,  93,  94,  95,  96,  97, 100],\n",
       "       [ 99,   0,   1,   2,   3,   4,   5,   6,   7,   8,   9,  10,  11,\n",
       "         12,  13,  14,  15,  16,  17,  18,  19,  20,  21,  22,  23,  24,\n",
       "         25,  26,  27,  28,  29,  30,  31,  32,  33,  34,  35,  36,  37,\n",
       "         38,  39,  40,  41,  42,  43,  44,  45,  46,  47,  48,  49,  50,\n",
       "         51,  52,  53,  54,  55,  56,  57,  58,  59,  60,  61,  62,  63,\n",
       "         64,  65,  66,  67,  68,  69,  70,  71,  72,  73,  74,  75,  76,\n",
       "         77,  78,  79,  80,  81,  82,  83,  84,  85,  86,  87,  88,  89,\n",
       "         90,  91,  92,  93,  94,  95,  96,  97,  99]], dtype=int32)"
      ]
     },
     "execution_count": 18,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "# 訓練データの準備\n",
    "# train_data[0]がy、train_data[1]がxの方\n",
    "# a_1を0にしたので添字がひとつずれている\n",
    "train_data = np.ndarray((2, p), dtype=np.int32)\n",
    "#最初と最後だけ1違うように設定\n",
    "train_data[0][0] = train_data[0][p-1] = p\n",
    "train_data[1][0] = train_data[1][p-1] = p-1\n",
    "#最初と最後以外を、0からの数字に設定\n",
    "for i in range(p-2):\n",
    "    train_data[0][i+1] = i\n",
    "    train_data[1][i+1] = i\n",
    "# 訓練データの表示\n",
    "#print(train_data[0])\n",
    "#print(train_data[1])\n",
    "print(train_data)\n",
    "print(\"文字列長\" , p )\n",
    "train_data"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 19,
   "metadata": {
    "collapsed": false
   },
   "outputs": [],
   "source": [
    "# モデルの準備\n",
    "lstm = LSTM(p+1 , n_units)\n",
    "model = L.Classifier(lstm)\n",
    "model.compute_accuracy = False\n",
    "for param in model.params():\n",
    "    data = param.data\n",
    "    data[:] = np.random.uniform(-0.2, 0.2, data.shape)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 20,
   "metadata": {
    "collapsed": true
   },
   "outputs": [],
   "source": [
    "# optimizerの設定\n",
    "optimizer = optimizers.Adam()\n",
    "optimizer.setup(model)\n",
    "i = 0"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 22,
   "metadata": {
    "collapsed": false,
    "scrolled": false
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "sequence:0, loss:2.3131747245788574\n",
      "prediction: 100,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,100,\n",
      "probability: [[ -9.75691378e-01  -1.46450901e+00  -1.35265601e+00  -7.80297279e-01\n",
      "    2.26497650e-03   5.75392395e-02   1.95020318e-01   2.25866467e-01\n",
      "    3.88968349e-01  -6.52602375e-01  -8.47511709e-01  -3.50099891e-01\n",
      "    2.02427313e-01  -1.14175940e+00  -1.44704258e+00  -1.17254996e+00\n",
      "   -7.35675335e-01  -1.05612624e+00  -8.95549417e-01  -7.77476609e-01\n",
      "   -1.14597452e+00  -1.22852623e+00   3.04384112e-01  -1.23588979e+00\n",
      "   -1.10715985e+00  -1.31770492e+00  -1.31221414e+00  -6.79996908e-01\n",
      "   -1.54840779e+00  -1.84422278e+00  -8.48978832e-02   4.86990333e-01\n",
      "   -2.82949376e+00  -4.69216377e-01  -1.52491510e-01  -2.27326584e+00\n",
      "   -1.27510834e+00  -2.53185534e+00  -2.82115555e+00  -1.74895954e+00\n",
      "   -1.15190578e+00  -1.24660742e+00  -1.65452933e+00  -4.08091247e-01\n",
      "   -1.62559676e+00  -2.27686167e+00  -3.11000347e+00  -2.79753900e+00\n",
      "   -2.42009783e+00  -8.46246779e-01  -6.34886265e-01  -1.67038441e-01\n",
      "   -2.80714107e+00  -3.32019067e+00  -1.69690561e+00  -7.27388620e-01\n",
      "   -2.22028232e+00  -1.66329896e+00  -9.28089440e-01  -2.56167507e+00\n",
      "   -1.48484993e+00  -7.67075658e-01  -1.55103755e+00  -2.09706879e+00\n",
      "   -1.26257765e+00  -1.09554458e+00  -5.55922240e-02  -1.64363670e+00\n",
      "   -1.53896439e+00  -2.73201227e+00  -4.24718976e-01  -1.91129252e-01\n",
      "   -1.34221709e+00  -2.00240517e+00  -1.94517970e+00  -3.15941429e+00\n",
      "   -1.04113424e+00  -5.98772347e-01  -2.54190731e+00  -2.17754483e+00\n",
      "   -1.42101121e+00   4.50482517e-02  -9.82119679e-01  -2.67091703e+00\n",
      "   -4.64195967e-01   1.01518281e-01  -1.41327292e-01  -3.00170779e+00\n",
      "   -1.51756167e+00  -1.78811681e+00  -2.31574249e+00  -1.01443815e+00\n",
      "   -1.34041548e+00  -1.07484531e+00  -1.44512284e+00  -1.17199087e+00\n",
      "   -1.27171528e+00  -1.66880441e+00  -4.71421194e+00   5.55505180e+00\n",
      "    7.41596317e+00]]\n",
      "prediction: 99,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,100,\n",
      "probability: [[ -9.75691557e-01  -1.46450901e+00  -1.35265589e+00  -7.80297160e-01\n",
      "    2.26503611e-03   5.75390607e-02   1.95020586e-01   2.25866348e-01\n",
      "    3.88968110e-01  -6.52602434e-01  -8.47511828e-01  -3.50100040e-01\n",
      "    2.02427328e-01  -1.14175951e+00  -1.44704247e+00  -1.17254996e+00\n",
      "   -7.35675216e-01  -1.05612612e+00  -8.95549536e-01  -7.77476549e-01\n",
      "   -1.14597452e+00  -1.22852623e+00   3.04384053e-01  -1.23588979e+00\n",
      "   -1.10715985e+00  -1.31770492e+00  -1.31221437e+00  -6.79997087e-01\n",
      "   -1.54840755e+00  -1.84422266e+00  -8.48977491e-02   4.86990422e-01\n",
      "   -2.82949376e+00  -4.69216466e-01  -1.52491540e-01  -2.27326584e+00\n",
      "   -1.27510834e+00  -2.53185511e+00  -2.82115555e+00  -1.74895954e+00\n",
      "   -1.15190578e+00  -1.24660718e+00  -1.65452957e+00  -4.08091307e-01\n",
      "   -1.62559676e+00  -2.27686167e+00  -3.11000323e+00  -2.79753923e+00\n",
      "   -2.42009783e+00  -8.46246839e-01  -6.34886444e-01  -1.67038277e-01\n",
      "   -2.80714083e+00  -3.32019043e+00  -1.69690561e+00  -7.27388501e-01\n",
      "   -2.22028232e+00  -1.66329896e+00  -9.28089440e-01  -2.56167507e+00\n",
      "   -1.48485029e+00  -7.67075837e-01  -1.55103767e+00  -2.09706855e+00\n",
      "   -1.26257765e+00  -1.09554470e+00  -5.55920750e-02  -1.64363670e+00\n",
      "   -1.53896427e+00  -2.73201180e+00  -4.24719095e-01  -1.91129431e-01\n",
      "   -1.34221733e+00  -2.00240517e+00  -1.94517994e+00  -3.15941429e+00\n",
      "   -1.04113424e+00  -5.98772228e-01  -2.54190755e+00  -2.17754507e+00\n",
      "   -1.42101145e+00   4.50482219e-02  -9.82119679e-01  -2.67091727e+00\n",
      "   -4.64196086e-01   1.01518281e-01  -1.41327396e-01  -3.00170779e+00\n",
      "   -1.51756155e+00  -1.78811657e+00  -2.31574249e+00  -1.01443815e+00\n",
      "   -1.34041560e+00  -1.07484531e+00  -1.44512284e+00  -1.17199063e+00\n",
      "   -1.27171528e+00  -1.66880441e+00  -4.71421194e+00   5.55505180e+00\n",
      "    7.41596365e+00]]\n"
     ]
    },
    {
     "ename": "KeyboardInterrupt",
     "evalue": "",
     "output_type": "error",
     "traceback": [
      "\u001b[0;31m---------------------------------------------------------------------------\u001b[0m",
      "\u001b[0;31mKeyboardInterrupt\u001b[0m                         Traceback (most recent call last)",
      "\u001b[0;32m<ipython-input-22-270ea9f980a1>\u001b[0m in \u001b[0;36m<module>\u001b[0;34m()\u001b[0m\n\u001b[1;32m     16\u001b[0m         \u001b[0;31m# 最適化の実行\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m     17\u001b[0m         \u001b[0mmodel\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mzerograds\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m---> 18\u001b[0;31m         \u001b[0mloss\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mbackward\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m     19\u001b[0m         \u001b[0moptimizer\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mupdate\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m     20\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;32m/Users/sasakikensuke/.pyenv/versions/3.5.1/lib/python3.5/site-packages/chainer/variable.py\u001b[0m in \u001b[0;36mbackward\u001b[0;34m(self, retain_grad)\u001b[0m\n\u001b[1;32m    347\u001b[0m                 \u001b[0mhook\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mbackward_preprocess\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mfunc\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0min_data\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mout_grad\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    348\u001b[0m             \u001b[0;32mwith\u001b[0m \u001b[0mcuda\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mget_device\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m*\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0min_data\u001b[0m \u001b[0;34m+\u001b[0m \u001b[0mout_grad\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m--> 349\u001b[0;31m                 \u001b[0mgxs\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mfunc\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mbackward\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0min_data\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mout_grad\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m    350\u001b[0m             \u001b[0;32massert\u001b[0m \u001b[0mlen\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mgxs\u001b[0m\u001b[0;34m)\u001b[0m \u001b[0;34m==\u001b[0m \u001b[0mlen\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0min_data\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    351\u001b[0m             \u001b[0;32mfor\u001b[0m \u001b[0mhook\u001b[0m \u001b[0;32min\u001b[0m \u001b[0msix\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mitervalues\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mhooks\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;32m/Users/sasakikensuke/.pyenv/versions/3.5.1/lib/python3.5/site-packages/chainer/functions/connection/linear.py\u001b[0m in \u001b[0;36mbackward\u001b[0;34m(self, inputs, grad_outputs)\u001b[0m\n\u001b[1;32m     46\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m     47\u001b[0m         \u001b[0mgx\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mgy\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mdot\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mW\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mastype\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mx\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mdtype\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mreshape\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0minputs\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0;36m0\u001b[0m\u001b[0;34m]\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mshape\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m---> 48\u001b[0;31m         \u001b[0mgW\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mgy\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mT\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mdot\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mx\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mastype\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mW\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mdtype\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m     49\u001b[0m         \u001b[0;32mif\u001b[0m \u001b[0mlen\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0minputs\u001b[0m\u001b[0;34m)\u001b[0m \u001b[0;34m==\u001b[0m \u001b[0;36m3\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m     50\u001b[0m             \u001b[0mgb\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mgy\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0msum\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;36m0\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;31mKeyboardInterrupt\u001b[0m: "
     ]
    }
   ],
   "source": [
    "# 訓練を行うループ\n",
    "display = 5000# 何回ごとに表示するか\n",
    "total_loss = 0  # 誤差関数の値を入れる変数\n",
    "for seq in range(5001):\n",
    "    sequence = train_data[(np.random.randint(2))] # ランダムにどちらかの文字列を選ぶ\n",
    "    lstm.reset_state()  # 前の系列の影響がなくなるようにリセット\n",
    "    for i in six.moves.range(p-1):\n",
    "        x = chainer.Variable(np.asarray([sequence[i]]))   # i文字目を入力に\n",
    "        t = chainer.Variable(np.asarray([sequence[i+1]])) # i+1文字目を正解に\n",
    "        loss = model(x,t)  # lossの計算\n",
    "\n",
    "        # 出力する時はlossを記憶\n",
    "        if seq%display==0:\n",
    "            total_loss += loss.data\n",
    "\n",
    "        # 最適化の実行\n",
    "        model.zerograds()\n",
    "        loss.backward()\n",
    "        optimizer.update()\n",
    "\n",
    "    # lossの表示\n",
    "    if seq%display==0:\n",
    "        print(\"sequence:{}, loss:{}\".format(seq, total_loss))\n",
    "        total_loss = 0\n",
    "    # 出力5回に1回、系列(今は2系列ある)ごとの予測結果と最後の文字の確率分布を表示\n",
    "    #if seq%(display*5)==0:\n",
    "    if seq%(display*5)==0:\n",
    "        for select in six.moves.range(2):\n",
    "            sequence = train_data[select]\n",
    "            lstm.reset_state()\n",
    "            print(\"prediction: {},\".format(sequence[0]), end=\"\")\n",
    "            for i in six.moves.range(p-1):\n",
    "                x = chainer.Variable(np.asarray([sequence[i]]))\n",
    "                data = lstm(x).data\n",
    "                print(\"{},\".format(np.argmax(data)), end=\"\")\n",
    "            print()\n",
    "            print(\"probability: {}\".format(data))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "実験の詳細\n",
    "   　if seq%(display*5)==0:\n",
    "        for select in six.moves.range(2):                          ←与えた二つの数字列について\n",
    "            sequence = train_data[select]                          ←与えた二つの文字列をsequenceに代入\n",
    "            lstm.reset_state()　　　　　　　　　　　　　　　　　　 ←おそらくlstmのメモリユニットの状態をリセット\n",
    "            \n",
    "            print(\"prediction: {},\".format(sequence[0]), end=\"\")　 ←予測対象の先頭を表示\n",
    "            for i in six.moves.range(p-1):\n",
    "                x = chainer.Variable(np.asarray([sequence[i]]))\n",
    "                data = lstm(x).data\n",
    "                print(\"{},\".format(np.argmax(data)), end=\"\")\n",
    "            print()\n",
    "            print(\"probability: {}\".format(data))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 16,
   "metadata": {
    "collapsed": false
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "probability: [[-3.55489802 -3.85977697 -3.36345339 -4.02523661  9.61575413 -2.92241359]]:\n"
     ]
    }
   ],
   "source": [
    "print(\"probability: {}:\".format(data))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": false
   },
   "outputs": [],
   "source": [
    "np.random.random(2)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {
    "collapsed": false
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Help on class LSTM in module chainer.functions.activation.lstm:\n",
      "\n",
      "class LSTM(chainer.function.Function)\n",
      " |  Long short-term memory unit with forget gate.\n",
      " |  \n",
      " |  It has two inputs (c, x) and two outputs (c, h), where c indicates the cell\n",
      " |  state. x must have four times channels compared to the number of units.\n",
      " |  \n",
      " |  Method resolution order:\n",
      " |      LSTM\n",
      " |      chainer.function.Function\n",
      " |      builtins.object\n",
      " |  \n",
      " |  Methods defined here:\n",
      " |  \n",
      " |  backward(self, inputs, grad_outputs)\n",
      " |      Applies backprop to output gradient arrays.\n",
      " |      \n",
      " |      It delegates the procedure to :meth:`backward_cpu` or\n",
      " |      :meth:`backward_gpu` by default. Which it selects is determined by the\n",
      " |      type of input arrays and output gradient arrays. Implementations of\n",
      " |      :class:`Function` must implement either CPU/GPU methods or this method,\n",
      " |      if the function is intended to be backprop-ed.\n",
      " |      \n",
      " |      Args:\n",
      " |          inputs: Tuple of input arrays.\n",
      " |          grad_outputs: Tuple of output gradient arrays.\n",
      " |      \n",
      " |      Returns:\n",
      " |          tuple: Tuple of input gradient arrays. Some or all of them can be\n",
      " |          ``None``, if the function is not differentiable on\n",
      " |          inputs.\n",
      " |      \n",
      " |      .. warning::\n",
      " |      \n",
      " |          Implementations of :class:`Function` must take care that the\n",
      " |          return value must be a tuple even if it returns only one array.\n",
      " |  \n",
      " |  check_type_forward(self, in_types)\n",
      " |      Checks types of input data before forward propagation.\n",
      " |      \n",
      " |      Before :meth:`forward` is called, this function is called.\n",
      " |      You need to validate types of input data in this function\n",
      " |      using :ref:`the type checking utilities <type-check-utils>`.\n",
      " |      \n",
      " |      Args:\n",
      " |          in_types (~chainer.utils.type_check.TypeInfoTuple): The type\n",
      " |              information of input data for :meth:`forward`.\n",
      " |  \n",
      " |  forward(self, inputs)\n",
      " |      Applies forward propagation to input arrays.\n",
      " |      \n",
      " |      It delegates the procedure to :meth:`forward_cpu` or\n",
      " |      :meth:`forward_gpu` by default. Which it selects is determined by the\n",
      " |      type of input arrays.\n",
      " |      Implementations of :class:`Function` must implement either CPU/GPU\n",
      " |      methods or this method.\n",
      " |      \n",
      " |      Args:\n",
      " |          inputs: Tuple of input array(s).\n",
      " |      \n",
      " |      Returns:\n",
      " |          Tuple of output array(s).\n",
      " |      \n",
      " |      .. warning::\n",
      " |      \n",
      " |          Implementations of :class:`Function` must take care that the\n",
      " |          return value must be a tuple even if it returns only one array.\n",
      " |  \n",
      " |  ----------------------------------------------------------------------\n",
      " |  Methods inherited from chainer.function.Function:\n",
      " |  \n",
      " |  __call__(self, *inputs)\n",
      " |      Applies forward propagation with chaining backward references.\n",
      " |      \n",
      " |      Basic behavior is expressed in documentation of :class:`Function`\n",
      " |      class.\n",
      " |      \n",
      " |      .. note::\n",
      " |      \n",
      " |         If the :data:`~Variable.data` attribute of input variables exist on\n",
      " |         GPU device, then, before it calls :meth:`forward` method, the\n",
      " |         appropriate device is selected, so in most cases implementers do\n",
      " |         not need to take care of device selection.\n",
      " |      \n",
      " |      Args:\n",
      " |          inputs: Tuple of input :class:`Variable`, :class:`numpy.ndarray` or\n",
      " |              :class:`cupy.ndarray` objects. The volatile flags of all input\n",
      " |              variables must agree. If the input is an :class:`numpy.ndarray`\n",
      " |              or a :class:`cupy.ndarray`, it is automatically wrapped with\n",
      " |              :class:`Variable`.\n",
      " |      \n",
      " |      Returns:\n",
      " |          One :class:`Variable` object or a tuple of multiple\n",
      " |          :class:`Variable` objects.\n",
      " |  \n",
      " |  add_hook(self, hook, name=None)\n",
      " |      Registers the function hook.\n",
      " |      \n",
      " |      Args:\n",
      " |          hook(~chainer.function.FunctionHook):\n",
      " |              the function hook to be registered.\n",
      " |          name(str): The name of the function hook.\n",
      " |              name must be unique among function hooks\n",
      " |              registered to the function. If ``None``,\n",
      " |              default name of the function hook is used.\n",
      " |  \n",
      " |  backward_cpu(self, inputs, grad_outputs)\n",
      " |      Applies backprop to output gradient arrays on CPU.\n",
      " |      \n",
      " |      Args:\n",
      " |          inputs: Tuple of input :class:`numpy.ndarray` object(s).\n",
      " |          grad_outputs: Tuple of output gradient :class:`numpy.ndarray`\n",
      " |              object(s).\n",
      " |      \n",
      " |      Returns:\n",
      " |          tuple: Tuple of input gradient :class:`numpy.ndarray` object(s).\n",
      " |          Some or all of them can be ``None``, if the function is not\n",
      " |          differentiable on corresponding inputs.\n",
      " |      \n",
      " |      .. warning::\n",
      " |      \n",
      " |          Implementations of :class:`Function` must take care that the\n",
      " |          return value must be a tuple even if it returns only one array.\n",
      " |  \n",
      " |  backward_gpu(self, inputs, grad_outputs)\n",
      " |      Applies backprop to output gradient arrays on GPU.\n",
      " |      \n",
      " |      Args:\n",
      " |          inputs: Tuple of input :class:`cupy.ndarray`\n",
      " |              object(s).\n",
      " |          grad_outputs: Tuple of output gradient\n",
      " |              :class:`cupy.ndarray` object(s).\n",
      " |      \n",
      " |      Returns:\n",
      " |          tuple: Tuple of input gradient :class:`cupy.ndarray`\n",
      " |          object(s). Some or all of them can be ``None``, if the function is\n",
      " |          not differentiable on corresponding inputs.\n",
      " |      \n",
      " |      .. warning::\n",
      " |      \n",
      " |          Implementations of :class:`Function` must take care that the\n",
      " |          return value must be a tuple even if it returns only one array.\n",
      " |  \n",
      " |  delete_hook(self, name)\n",
      " |      Unregisters the function hook.\n",
      " |      \n",
      " |      Args:\n",
      " |          name(str): the name of the function hook\n",
      " |          to be unregistered.\n",
      " |  \n",
      " |  forward_cpu(self, inputs)\n",
      " |      Applies forward propagation to input arrays on CPU.\n",
      " |      \n",
      " |      Args:\n",
      " |          inputs: Tuple of :class:`numpy.ndarray` object(s).\n",
      " |      \n",
      " |      Returns:\n",
      " |          tuple: Tuple of :class:`numpy.ndarray` object(s).\n",
      " |      \n",
      " |      .. warning::\n",
      " |      \n",
      " |          Implementations of :class:`Function` must take care that the\n",
      " |          return value must be a tuple even if it returns only one array.\n",
      " |  \n",
      " |  forward_gpu(self, inputs)\n",
      " |      Applies forward propagation to input arrays on GPU.\n",
      " |      \n",
      " |      Args:\n",
      " |          inputs: Tuple of :class:`cupy.ndarray` object(s).\n",
      " |      \n",
      " |      Returns:\n",
      " |          tuple: Tuple of :class:`cupy.ndarray` object(s).\n",
      " |      \n",
      " |      .. warning::\n",
      " |      \n",
      " |          Implementations of :class:`Function` must take care that the\n",
      " |          return value must be a tuple even if it returns only one array.\n",
      " |  \n",
      " |  unchain(self)\n",
      " |      Purges in/out variables and this function itself from the graph.\n",
      " |      \n",
      " |      This method is called from :meth:`Variable.unchain_backward` method.\n",
      " |  \n",
      " |  ----------------------------------------------------------------------\n",
      " |  Data descriptors inherited from chainer.function.Function:\n",
      " |  \n",
      " |  __dict__\n",
      " |      dictionary for instance variables (if defined)\n",
      " |  \n",
      " |  __weakref__\n",
      " |      list of weak references to the object (if defined)\n",
      " |  \n",
      " |  label\n",
      " |      Short text that represents the function.\n",
      " |      \n",
      " |      The default implementation returns its type name.\n",
      " |      Each function should override it to give more information.\n",
      " |  \n",
      " |  local_function_hooks\n",
      " |      Ordered Dictionary of registered function hooks.\n",
      " |      \n",
      " |      Contrary to ``chainer.thread_local.function_hooks``,\n",
      " |      which registers its elements to all functions,\n",
      " |      Function hooks in this property is specific to this function.\n",
      " |  \n",
      " |  stack\n",
      " |  \n",
      " |  ----------------------------------------------------------------------\n",
      " |  Data and other attributes inherited from chainer.function.Function:\n",
      " |  \n",
      " |  type_check_enable = True\n",
      "\n"
     ]
    }
   ],
   "source": [
    "help(F.LSTM)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": true
   },
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.5.1"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 0
}
